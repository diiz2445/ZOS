## (6) Управление устройствами: основные процессы подсистемы, необходимость, назначение

1. **Общее описание**:
   - Управление устройствами — ключевая подсистема Unix/Linux, обеспечивающая взаимодействие ОС с аппаратным обеспечением через унифицированный интерфейс.
   - Позволяет использовать устройства (диски, сетевые карты, принтеры, веб-камеры и др.), скрывая их аппаратную сложность.

2. **Основные цели подсистемы**:
   - Абстрагирование от аппаратного обеспечения: стандартизированный интерфейс для устройств.
   - Управление ресурсами: распределение прерываний, адресов памяти, предотвращение конфликтов.
   - Обработка прерываний: своевременное реагирование на события устройств.
   - Обнаружение и инициализация устройств: автоматическое распознавание и настройка оборудования.
   - Интерфейс для приложений: доступ через системные вызовы.
   - Безопасность: контроль доступа, защита от несанкционированного использования.

3. **Основные процессы подсистемы**:
   - **Обнаружение и инициализация устройств**:
     - **Цель**: выявление и подготовка устройств к работе.
     - **Процесс**:
       - Ядро при загрузке обнаруживает устройства через шины (PCI, USB, SPI, I2C).
       - BIOS/UEFI выполняет первичную инициализацию.
       - ACPI предоставляет данные об устройствах и управляет питанием.
       - Plug and Play (PnP) обеспечивает автоматическую настройку.
     - **Результат**: идентификация устройств, загрузка драйверов, выделение ресурсов (IRQ, адреса памяти).
   - **Драйверы устройств**:
     - **Роль**: посредники между ядром и устройствами, преобразующие запросы в команды.
     - **Функции**:
       - Обработка прерываний.
       - Управление буферами данных.
       - Контроль энергопотребления.
     - **Типы драйверов**:
       - Символьные: для потокового ввода-вывода (клавиатуры, порты).
       - Блочные: для блочного ввода-вывода (диски, SSD).
       - Сетевые: для сетевых устройств (Ethernet, Wi-Fi).
     - **Управление**: загрузка/выгрузка модулей ядра.
       ```bash
       sudo modprobe usb-storage  # Загрузка модуля USB
       lsmod                     # Просмотр модулей
       sudo rmmod usb-storage    # Выгрузка модуля
       ```
   - **Файлы устройств**:
     - **Роль**: специальные файлы в `/dev`, представляющие устройства для приложений.
     - **Типы**:
       - Символьные: для символьных драйверов.
       - Блочные: для блочных драйверов.
     - **Примеры**:
       - `/dev/sda`: жесткий диск.
       - `/dev/ttyS0`: последовательный порт.
       - `/dev/random`: генератор случайных чисел.
     - **Использование**:
       ```bash
       sudo dd if=/dev/sda of=mbr.bin bs=512 count=1  # Чтение MBR
       sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress  # Запись на USB
       sudo mknod /dev/mydevice c 250 0  # Создание файла устройства
       ```
   - **Системные вызовы**:
     - **Роль**: интерфейс между приложениями и ядром для операций с устройствами.
     - **Примеры**:
       - `open()`: открытие устройства.
       - `read()`: чтение данных.
       - `write()`: запись данных.
       - `close()`: закрытие устройства.
       - `ioctl()`: специфические операции.
     - **Пример кода**:
       ```c
       #include <fcntl.h>
       #include <unistd.h>
       int main() {
           int fd = open("/dev/ttyS0", O_RDWR);
           char buffer[10];
           read(fd, buffer, 10);
           write(fd, "Hello", 5);
           close(fd);
           return 0;
       }
       ```
   - **Обработчики прерываний**:
     - **Роль**: обработка событий от устройств (нажатие клавиши, сетевой пакет).
     - **Механизм**:
       - Устройство генерирует IRQ.
       - Процессор использует IDT для вызова ISR.
       - ISR выполняет обработку, затем процесс восстанавливается.
   - **DMA (Прямой доступ к памяти)**:
     - **Роль**: передача данных без участия CPU.
     - **Механизм**: устройство через контроллер DMA передает данные в память.
     - **Преимущества**: снижение нагрузки на CPU, ускорение операций.
   - **udev (в Linux)**:
     - **Роль**: динамическое управление файлами устройств в `/dev`.
     - **Функции**:
       - Создание/удаление файлов устройств.
       - Настройка прав доступа через правила (`/etc/udev/rules.d/`).
       - Обработка событий ядра.
     - **Пример правила**:
       ```bash
       ACTION=="add", SUBSYSTEM=="usb", ATTR{idVendor}=="0781", ATTR{idProduct}=="5580", RUN+="/usr/bin/mount /dev/%k /mnt/usb"
       ```

4. **Необходимость подсистемы**:
   - **Стандартизация**: единый интерфейс для всех устройств.
   - **Безопасность**: контроль доступа, защита от вредоносных программ.
   - **Эффективность**: минимизация задержек, оптимизация ресурсов.
   - **Гибкость**: поддержка hotplug и новых устройств.
   - **Абстрагирование**: скрытие аппаратных деталей (например, запись на диск через `write()`).
   - **Конкурентный доступ**: управление очередями (например, демон печати `lp`).
   - **Эффективное использование ресурсов**: DMA, планировщики ввода-вывода (`echo deadline > /sys/block/sda/queue/scheduler`).
   - **Динамическое управление**: `udev` для hotplug (`udevadm monitor`).
   - **Энергопотребление**: ACPI и режимы сна.

5. **Назначение подсистемы**:
   - Обеспечение стабильной работы системы.
   - Высокая производительность ввода-вывода.
   - Безопасный доступ к оборудованию.
   - Гибкость в настройке и поддержке устройств.

6. **Заключение**:
   - Управление устройствами — основа Unix/Linux, критически важная для взаимодействия с оборудованием.
   - Необходима для разработчиков драйверов, администраторов и специалистов по ОС.

---

## (7) Управление пространством на устройстве выгрузки в Linux и Unix

1. **Общее описание**:
   - Swap-пространство — область на диске, дополняющая оперативную память (RAM) для временной выгрузки неактивных страниц памяти.
   - Решает задачи: управление swap-пространством, выгрузка (swap-out) и подкачка (swap-in) страниц.

2. **Особенности управления swap-пространством**:
   - Работает с непрерывными блоками данных (страницами памяти), а не файлами.
   - Оптимизировано для быстрого доступа к произвольным блокам.
   - Не требует иерархии файлов или журналирования.

3. **Эволюция механизмов выгрузки**:
   - **Исторические аспекты в Unix**:
     - Ранние версии использовали полный свопинг (перенос всего процесса).
     - Ограничение: размер процесса зависел от физической памяти.
   - **Страничная подкачка**:
     - Введена в BSD 4.0 (demand paging), обмен страницами, а не процессами.
     - Современный Linux усовершенствовал этот подход для гибкости и эффективности.

4. **Алгоритмы и структуры данных**:
   - **Таблица страниц процесса**:
     - Иерархия: PGD → PUD → PMD → PTE.
     - PTE содержит флаги (RWX, присутствие, модификация) и адрес страницы.
   - **swap_info_struct**:
     - Глобальный список, описывающий устройства/файлы подкачки.
     - Содержит: `swap_map` (битовая карта), приоритет, счетчик ссылок.
   - **swap_map**:
     - Битовая карта, где `1` — занятый блок, `0` — свободный.
     - Размер блока: `PAGE_SIZE` (обычно 4 КБ).
   - **swapon/swapoff**:
     - `swapon`: инициализирует swap-устройство, проверяет заголовок, добавляет в `swap_avail_list`.
     - `swapoff`: перемещает страницы в RAM или другие устройства.
   - **Кластеризация**: группировка до 32 страниц в один I/O-запрос для снижения накладных расходов.
   - **zswap**: сжатие страниц в памяти перед записью на диск.
   - **swap prefetch**: предварительное чтение смежных страниц.

5. **Swap Out (выгрузка страниц)**:
   - **Условие**: низкий уровень свободной памяти (`vm.min_free_kbytes`, `vm.low_watermark`).
   - **Механизм**:
     - Демон `kswapd` сканирует LRU-списки: `Inactive_anon`, `Active_anon`, `Inactive_file`, `Active_file`.
     - Приоритет выгрузки: неактивные анонимные → неактивные файловые → активные.
     - Dirty-страницы записываются в swap через `struct bio`.
     - PTE обновляется: бит `Present` сбрасывается, сохраняется `swp_entry_t`.
   - **Оптимизации**:
     - Кластеризация.
     - Zswap (сжатие LZ4/LZO).
     - Swap prefetch.
   - **Ошибки**:
     - Нет свободных слотов: `direct reclaim` или OOM Killer.
     - Сбой записи: страница в `PG_swapcache`, повторная попытка.

6. **Swap In (подкачка страниц)**:
   - **Условие**: доступ к странице, выгруженной в swap (Page Fault, бит `Present=0`).
   - **Механизм**:
     - Извлечение `swp_entry_t` через `pte_to_swp_entry()`.
     - Чтение страницы через `struct bio` (`submit_bio(REQ_OP_READ)`).
     - Обновление PTE: бит `Present=1`, запись физического адреса.
     - Увеличение счетчика RSS.
   - **Оптимизации**:
     - Readahead: чтение соседних блоков.
     - Zswap: декомпрессия страниц.
   - **Ошибки**:
     - Повреждение swap: SIGBUS или завершение процесса.

7. **Заключение**:
   - Управление swap-пространством сочетает низкоуровневую работу с дисками, алгоритмы аллокации и синхронизацию для надежности и производительности.

---

## (8) Загрузка процесса в память

1. **Общее описание**:
   - Загрузка процесса в память включает создание процесса (`fork`, `vfork`, `clone`) и выполнение программы (`execve`) с использованием ELF-формата.

2. **Создание процесса**:
   - **fork()**:
     - Создает дочерний процесс, дублируя контекст родителя.
     - Использует Copy-On-Write (CoW): страницы копируются при записи.
     - Возвращает: PID в родителе, 0 в ребенке, -1 при ошибке (`EAGAIN`, `ENOMEM`).
   - **vfork()**:
     - Оптимизированная версия `fork` для вызова `execve`.
     - Родитель блокируется, дочерний использует его адресное пространство.
     - Возвращает: как `fork`.
   - **clone()**:
     - Гибкое создание процессов/потоков с контролем ресурсов через `flags` (`CLONE_VM`, `CLONE_FILES`).
     - Используется для потоков (`CLONE_THREAD`) и контейнеров (`CLONE_NEWNS`).

3. **Выполнение программы (execve)**:
   - **Сигнатура**: `execve(const char *pathname, char *const argv[], char *const envp[])`.
   - **Процесс**:
     - Проверка прав доступа к файлу.
     - Очистка старого адресного пространства (`mm_struct`).
     - Чтение ELF-заголовка и Program Header Table.
     - Вызов `mmap()` для сегментов PT_LOAD (код, данные).
     - Загрузка динамического загрузчика (PT_INTERP, обычно `/lib64/ld-linux-x86-64.so.2`).
     - Инициализация стека (`argv`, `envp`), запуск программы (`__libc_start_main` → `main`).

4. **Формат ELF**:
   - Стандартный формат для исполняемых файлов, библиотек.
   - Содержит: заголовок (магические байты `0x7F 'E' 'L' 'F'`), Program Header Table (сегменты: PT_LOAD, PT_INTERP), Section Header Table (для компоновки).

5. **Таблицы страниц и MMU**:
   - **mm_struct**: структура процесса, содержащая таблицы страниц (PGD → PUD → PMD → PTE).
   - **MMU**: преобразует виртуальные адреса в физические через таблицы страниц.
   - **TLB**: кэш для ускорения трансляции адресов.
   - **Page Fault**: исключение при отсутствии страницы или нарушении прав.

6. **Demand Paging**:
   - Страницы загружаются по требованию (lazy mapping).
   - При доступе к странице с `PRESENT=0`:
     - Page Fault вызывает загрузку данных из ELF-файла или swap.
     - Обновляется PTE, процесс продолжается.
   - Экономит RAM и ускоряет запуск.

7. **Свопинг и overcommit**:
   - При нехватке RAM страницы выгружаются в swap по алгоритму LRU.
   - Overcommit позволяет выделять больше памяти, чем доступно.

---

## (9) Функции управления процессами работы с памятью в ОС Linux

1. **Цели управления памятью**:
   - Изоляция процессов: предотвращение вмешательства.
   - Эффективное использование RAM: минимизация фрагментации.
   - Защита данных: контроль прав доступа.
   - Масштабируемость: поддержка больших объемов памяти.

2. **Системные вызовы**:
   - **brk() / sbrk()**:
     - Управление кучей: установка/увеличение границы кучи.
     - Пример:
       ```c
       #include <unistd.h>
       int main() {
           void *start = sbrk(0);
           sbrk(4096);
           void *end = sbrk(0);
           printf("Heap expanded from %p to %p\n", start, end);
           return 0;
       }
       ```
     - Ограничения: неэффективен для больших блоков, современные аллокаторы используют `mmap`.
   - **mmap()**:
     - Отображение файлов или анонимной памяти.
     - Сигнатура: `mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)`.
     - Типы: анонимная память, файловое отображение.
     - Пример:
       ```c
       void *mem = mmap(NULL, 1024*1024, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
       ```
     - Освобождение: `munmap(mem, length)`.
   - **mprotect()**:
     - Изменение прав доступа страниц.
     - Пример:
       ```c
       #include <sys/mman.h>
       int main() {
           char buffer[4096];
           mprotect(buffer, 4096, PROT_READ | PROT_WRITE);
           return 0;
       }
       ```

3. **Алгоритмы выделения памяти**:
   - **Уровень ядра**:
     - **Buddy Allocator**: управление физической памятью (блоки 2^n страниц).
     - **Slab Allocator**: выделение мелких объектов (кэши: полные, частичные, пустые).
   - **Уровень пользователя**:
     - **ptmalloc (glibc)**: использует `brk` для малых блоков, `mmap` для больших.
     - **jemalloc**: снижает фрагментацию, эффективен для многопоточных приложений.
     - **tcmalloc**: использует thread-local кэши.

4. **Инструменты анализа**:
   - **pmap**: карта памяти процесса (`pmap -X <PID>`).
   - **valgrind**: поиск утечек (`valgrind --tool=memcheck`).
   - **strace**: трассировка вызовов (`strace -e mmap,munmap,brk`).

5. **Пример полного цикла**:
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <sys/mman.h>
   int main() {
       int *arr = malloc(100 * sizeof(int));
       arr[0] = 42;
       void *mem = mmap(NULL, 1024*1024, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
       *(int*)mem = 100;
       mprotect(mem, 4096, PROT_READ);
       free(arr);
       munmap(mem, 1024*1024);
       return 0;
   }
   ```

---

## (10) Отказы

1. **Общее описание**:
   - Отказы — сбои, нарушающие работу системы, приложений или компонентов (аппаратные, программные, ядро, пользовательское пространство).

2. **Типы отказов**:
   - **Аппаратные**: сбои дисков, памяти, процессоров, проблемы питания.
   - **Ядро**: Kernel Panic из-за ошибок драйверов.
   - **Сетевые**: потеря соединения, ошибки DNS.
   - **Пользовательское пространство**: Segmentation Fault, падение сервисов, утечки ресурсов.
   - **Файловые системы**: повреждение данных, ошибки структуры.
   - **Память**: сбои виртуальной памяти, swap-проблемы.

3. **Средства обработки отказов**:
   - **Журналирование**: журналы файловых систем (ext4, XFS) для восстановления.
   - **Мониторинг**: `syslog`, `journalctl`, Prometheus, Nagios.
   - **Восстановление**:
     - Перезапуск служб (`systemd`, `supervisord`).
     - RAID для отказоустойчивости дисков.
     - Кластеризация (`Pacemaker/Corosync`).
   - **Отладка**:
     - `dmesg`: логи ядра.
     - `strace`, `gdb`: трассировка и отладка.
     - `lsmod`, `lspci/lsusb`: диагностика модулей и устройств.
   - **Резервирование**: регулярное резервное копирование.

4. **Методы предотвращения**:
   - **Обновления системы**: исправление уязвимостей.
   - **Права доступа**: `chmod`, `chown`.
   - **Ограничение привилегий**: отключение eBPF, изоляция namespaces.

5. **Философия устойчивости**:
   - **Модульность**: независимые компоненты.
   - **Fail fast**: быстрая остановка при ошибках.
   - **Изоляция процессов**: отдельные адресные пространства.

6. **Отказы памяти**:
   - **Повреждение swap**:
     - Причины: аппаратные сбои (бэд-секторы, износ SSD), некорректное завершение.
     - Последствия: ошибки чтения, SIGBUS, Kernel Panic.
   - **Переполнение swap**:
     - Причины: нехватка RAM, утечки памяти, высокое `vm.swappiness`.
     - Последствия: ошибки `Cannot allocate memory`, зависания, OOM Killer.
   - **OOM Killer**:
     - Завершает процессы при нехватке памяти.
     - Оценка по `badness score` (потребление памяти, время работы, привилегии).
   - **Page Fault**:
     - **Типы**:
       - Major Fault: страница в swap, требует чтения с диска.
       - Minor Fault: страница в RAM, но не привязана (например, CoW).
       - Invalid Fault: доступ к несуществующей странице → SIGSEGV.
     - **Обработка**:
       - Major: загрузка страницы, обновление PTE.
       - Minor: связывание страницы, обновление счетчиков.
       - Invalid: сигнал SIGSEGV, завершение процесса.
   - **Segmentation Fault**:
     - Причины: доступ к запрещенной/несуществующей памяти, неинициализированные указатели.
     - Результат: SIGSEGV, завершение процесса.

